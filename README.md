# Yoyo Engine (WIP)

My 2D Game Engine written in C, based off of SDL.

Provides most functionality you would expect from a modern game engine, including a visual editor, launcher, and build system.

The editor projects are setup in such a way that all of your game logic can be implemented in C, or you can forgo C entirely and use lua scripting for your game logic. There is nothing stopping you from using both.

This repository comes with most library dependencies, but you will need to install some of the external dependencies listed later in this readme.

![Drawing](https://github.com/Yoyolick/SCDG/assets/43967290/f98545d1-c4ba-419e-a674-da436f591d23)

## Documentation

I provide autogenerated documentation using doxygen [here](https://yoyolick.github.io/yoyoengine).
There are some custom pages explaining how to get up and running, also see some examples in the 'examples' directory of this repository.

## Notices

This section is temporary and will be used to denote any important facts I need to remember about the project.

- The coordinate system is non standard, north is -y, south is +y, east is +x, west is -x
- only text or png images can have their alpha modulated
- The engine is single threaded (except for audio)
- Logging is unavailable until the engine is initialized (SDL needs loaded before we can use it)
- THE LAUNCHER AND EDITOR TOOLCHAIN HAS ONLY BEEN TESTED ON LINUX. OPEN AN ISSUE IF YOU NEED WINDOWS SUPPORT.
- NOTE: make this section limitations and have a seperate notices
- DO NOT USE SPACES IN FILE NAMES, this will break a lot of the file operations especially in the editor, core might be fine though.

### editor

- zooming too far out really messes with the SDL line renderer, and you will see weird visual artifacts.

## Dependencies

> [!WARNING]  
> You will need all of the below dependencies installed, besides the **Core & Editor** dependencies, as they come preinstalled.

### Tooling

- A C compiler (gcc, clang, etc) (Mingw for cross compilation)
- [git](https://git-scm.com/)
- [cmake](https://cmake.org/)
- [make](https://www.gnu.org/software/make/)
- [python3](https://www.python.org/)
- [pip](https://pypi.org/project/pip/)

### Core & Editor

> [!NOTE]  
> All of these libraries are included in this repository, and do not need to be installed.

- [SDL2](https://www.libsdl.org/)
- [SDL2_image](https://www.libsdl.org/projects/SDL_image/)
- [SDL2_ttf](https://www.libsdl.org/projects/SDL_ttf/)
- [SDL2_mixer](https://www.libsdl.org/projects/SDL_mixer/)
- [uthash](https://github.com/troydhanson/uthash)
- [Nuklear](https://github.com/Immediate-Mode-UI/Nuklear)
- [jansson](https://github.com/akheron/jansson)

### Launcher / Project Manager

- [tkinter](https://docs.python.org/3/library/tkinter.html)
- [CustomTkinter](https://customtkinter.tomschimansky.com/)
- [CTkMessagebox](https://github.com/Akascape/CTkMessagebox)

## Launcher

There is a project manager and editor launcher in the "editor" directory. This is currently a work in progress and requires some python tkinter deps to be installed, but if you run it, it should function. It is currently only tested on linux.

You can create, delete, and launch projects through this easily.

## Editor

> [!WARNING]  
> The editor has only been tested on linux, and is incomplete. IT WILL PROBABLY NOT RUN ON WINDOWS!!!

The editor is currently being worked on as a visual scene editor and build manager.

## Core

The core engine is implemented in C, with a possible Cpython wrapper available later on. Extensive docs to the framework API will be linked here when complete.

## Plans

These plans are currently sorted in order of my anticipated completion.

- [X] Basic engine functionality (Audio, Rendering, Text, etc)
- [X] Nuklear UI integration
- [x] Entity Component System
- [X] Serialization
- [X] Visual Editor
- [ ] Implement native C scripting
- [ ] Lua Scripting API
- [ ] Collision detection
- [ ] Stabilize the core framework API
- [ ] Overhaul the Project Manager
- [ ] Example projects and tutorials
- [ ] Documentation website

Some features that aren't planned but I would like to implement eventually:

- [ ] Networking (Stretch for after 1.0)
- [ ] Implement a Cpython wrapper
- [ ] Bundling assets into production data files
- [ ] 3D rendering
- [ ] Mac support
- [ ] VR support?

## C scripting

Since I have transitioned this project to be more of an engine and less of a framework, by using the launcher to create a new project you will recieve a structure that is preconfigured to build and run a game by default.
In order to define custom behavior (ie: actually script your game) you should make note of the `custom/` directory created in your project folder.

```txt
custom
├── include
│   └── yoyo_c_api.h
├── lib
└── src
```

This directory is where all of your code for the game should go. You will notice that its only populated with one file by default, which we will touch on in a minute.

### To link libraries

All you need to do is place your library files in `custom/lib/<platform>` and the build system will link them automatically. You will need to create the platform directories for any platforms you want to build for, and you will encounter errors trying to link against libs for any platform that doesnt have them in this directory.

### Headers

`include` is provided for your convenience, and is added to the include path automatically. You can place any headers you want to use in here. The compiler knows to look in this directory, so you can define any headers here. I dont think you can nest in subdirectories though but if you want to it should be trivial to modify the build script or you can always open an issue and id be happy to add that.

`yoyo_c_api.h` is an interesting workaround to a cmake issue. We cant define macros inside of source files, so you will need to open this header and uncomment any of the macros for implementing api functions. I will provide an example of this below if that didnt make sense.

### Scripting

Any Scripting you do in C will be done through interfacing api functions extended by the engine and game template. If you really want to, you could modify `entry.c` to customize some behavior, but practically speaking anything you could change in there can also be done through the C api.

To get started, lets assume we made a file called `custom/src/game.c` and we want to print out "Hello Yoyo Engine!" when the engine starts.
Taking a look at the contents of `custom/include/yoyo_c_api.h` we can see that there is a macro called `YOYO_POST_INIT` that lets the engine know that we have implemented the signature `yoyo_post_init()`.

Knowing this, all we need to do is uncomment the macro defining that function, and then actually implement it somewhere in our source. Let's go into `game.c` and do so now.

```c
#include "yoyo_c_api.h"

void yoyo_post_init(){
    printf("Hello Yoyo Engine!\n");
}
```

And its really as simple as that. Taking a peek at `yoyo_c_api.h` you can see more information on what callbacks are available to you and when they are run, which can be combined in such a manner that you can achieve any behavior you want.

### Parting Notes

Is this not enough to achieve what you want?
Keep in mind that you can also use lua scripting to more directly and easily interface with the engine, but you might not have the same level of control as C. Does that also not solve your problem? The final option open to you is writing a custom Trick (The engines name for a plugin). More information on that follows in the next section.

## Tricks (Plugin/Module System)

Plugins are called "tricks". They live in subdirectories of the project folder `/tricks` and have a directory structure like this:

```txt
example/
├── include
│   └── example_header.h
├── lib
│   └── linux
│       └── libexamplelinkedlib.so
├── src
│   └── main.c
└── trick.yoyo
```

`trick.yoyo` contains the metadata for the trick, which is required to load it. It is a json file with the following structure:

```json
{
    "name":"example_trick",
    "description":"example trick",
    "author":"Ryan Zmuda",
    "version":"1.0"
}
```

any .c files in src will be compiled together, and by naming certain functions to match the engine callbcks you can interface with the exposed trick event system.

```c
#include <yoyoengine/yoyoengine.h>

void yoyo_trick_on_load(){
    /*
        runs when the trick is first mounted, which happens after all other init
    */
}

void yoyo_trick_on_unload(){
    /*
        runs when the trick is about to be unloaded, which is one of the
        first things to happen on engine shutdown
    */
}

void yoyo_trick_on_update(){
    /*
        runs once every ye_process_frame call, before the lua script
        callbacks and before rendering
    */
}
```

The engine at build time will make a few assumptions about your trick:

- It has a valid `trick.yoyo` in its root
- It has a valid `CMakeLists.txt` in its root
- It's `CMakeLists.txt` is setup in a way to build a shared library into `YOYO_TRICK_BUILD_DIR`
- Any headers that you want to be accessable to the runtime are in an `include/` directory in the root of the trick

I've deliberately left it up to the developer to create their own build script, as it gives much more control over dependancy management and build settings in general.

Because of this, it is also up to the developer to make sure they are outputting the trick in the directory that the engine will be looking for during project build time, which is `YOYO_TRICK_BUILD_DIR`.

You can ensure you are building into the correct directory by adding the following to your `CMakeLists.txt`:

```cmake
set_target_properties(example PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${YOYO_TRICK_BUILD_DIR}) # linux
set_target_properties(example PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${YOYO_TRICK_BUILD_DIR}) # windows
```

You need ***BOTH*** of these properties to account for windows AND linux builds.

> [!WARNING]  
> Because tricks load after initialization and are unloaded shortly before shutdown, **it is imperative that their exposed functionality is not attempted to be invoked outside the duration of its lifecycle**. This is not enforced by the engine, and will result in undefined behavior if violated.

## Credit

- The listed dependencies and Jojo's Bizarre Adventure for the bootup screen sound effect.
