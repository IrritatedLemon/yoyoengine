"""
    This file is a part of yoyoengine. (https://github.com/yoyolick/yoyoengine)
    Copyright (C) 2023  Ryan Zmuda

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import os
import sys
import shutil
import subprocess
import json

# returns whether we specified some cli args
def parse_args():
    args = sys.argv[1:]
    return '--run' in args, '--clean' in args

class YoyoEngineBuildSystem:
    def __init__(self, script_version="v2.0.0"):
        self.script_version = script_version

        # get cli args
        self.run_flag, self.clean_flag = parse_args()
        
        # chdir to where the script is located (to access things relatively)
        self.script_location = os.path.dirname(os.path.abspath(__file__))
        os.chdir(self.script_location)

        # get the game data
        with open("settings.yoyo", "r") as file:
            self.game_settings = json.load(file)

        # get the build settings
        with open("build.yoyo", "r") as file:
            self.build_settings = json.load(file)

        self.game_name = self.game_settings["name"].replace(" ", "_")
        self.game_platform = self.build_settings["platform"]
        self.build_cflags = self.build_settings["cflags"]

        # we need the path to the engine, but only to specify its CMakeLists.txt
        self.build_engine_path = self.build_settings["engine_build_path"]
        # Check if the engine build path exists
        if not os.path.exists(self.build_engine_path):
            print("[YOYO BUILD] Error: Engine build path \"" + self.build_engine_path + "\" does not exist.")
            print("[YOYO BUILD] Please set the engine build path in build.yoyo to the path of the engine build folder you want to use.")
            sys.exit()
        
        # if we recieved arg --clean OR there is no /build/out dir existant, we need to fresh configure and build
        if self.clean_flag or not os.path.exists("./build/out"):
            
            # Create a build/out folder
            if os.path.exists("./build/out"):
                shutil.rmtree("./build/out")
            os.makedirs("./build/out")
    
    def configure(self):
        # write our CMakeLists.txt file and run cmake .. to configure
        print("[YOYO BUILD] Configuring \"" + self.game_name + "\" for " + self.game_platform + " with flags: " + self.build_cflags)
        
        # Ensure the build directory exists
        if not os.path.exists("./build"):
            os.makedirs("./build")

        # Ensure the build/out directory exists
        if not os.path.exists("./build/out"):
            os.makedirs("./build/out")

        # create a CMakeLists.txt file in that folder
        cmake_file = open("./build/CMakeLists.txt", "w")

        # write the contents
        cmake_file.write(f"""
        ############################################################################
        # This file was automatically generated by Yoyo Engine Build System {self.script_version} #
        ############################################################################

        cmake_minimum_required(VERSION 3.22.1)
        project({self.game_name})

        add_subdirectory("{self.build_engine_path}/.." yoyoengine)
        include_directories(include ${{CMAKE_BINARY_DIR}}/bin/${{CMAKE_SYSTEM_NAME}}/include)

        set(CMAKE_C_FLAGS "${{CMAKE_C_FLAGS}} {self.build_cflags}")

        set(SOURCES "{self.script_location}/entry.c")

        file(GLOB CUSTOM_SOURCES "{self.script_location}/custom/src/*.c")

        add_executable({self.game_name} ${{SOURCES}} ${{CUSTOM_SOURCES}})

        include_directories({self.script_location}/custom/include)

        target_link_directories({self.game_name} PRIVATE ${{CMAKE_BINARY_DIR}}/bin/${{CMAKE_SYSTEM_NAME}}/lib)

        target_link_libraries({self.game_name} PRIVATE yoyoengine)

        set_target_properties({self.game_name} PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${{CMAKE_BINARY_DIR}}/bin/${{CMAKE_SYSTEM_NAME}})

        file(COPY "../resources" DESTINATION ${{CMAKE_BINARY_DIR}}/bin/${{CMAKE_SYSTEM_NAME}})
        file(COPY "../settings.yoyo" DESTINATION ${{CMAKE_BINARY_DIR}}/bin/${{CMAKE_SYSTEM_NAME}})
        """)

        cmake_file.close()

        # create all toolchains we might need in the build folder
        toolchain_file = open("./build/toolchain-win.cmake", "w")
        toolchain_file.write("set(CMAKE_SYSTEM_NAME Windows)\nset(CMAKE_C_COMPILER x86_64-w64-mingw32-gcc)\nset(CMAKE_CXX_COMPILER x86_64-w64-mingw32-g++)\nset(CMAKE_FIND_ROOT_PATH /usr/x86_64-w64-mingw32)\nset(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)")
        toolchain_file.close()

        # run cmake
        print("----------------------------------")
        print("Running cmake...")
        print("----------------------------------")

        # chdir into the build folder
        os.chdir("./build/out")

        # run cmake
        if(self.game_platform == "linux"):
            subprocess.run(["cmake", ".."])
        elif(self.game_platform == "windows"):
            subprocess.run(["cmake", "-DCMAKE_TOOLCHAIN_FILE=./toolchain-win.cmake", ".."])
        else:
            print("Error: Unknown platform \"" + self.game_platform + "\"")
            sys.exit()
    
    def build(self):
        print("----------------------------------")
        print("Running make...")
        print("----------------------------------")

        # run make
        subprocess.run(["make"])

        # on windows, we need to copy the dlls from /lib into the executible dir
        if(self.game_platform == "windows"):
            shutil.copytree("./bin/Windows/lib/", "./bin/Windows/", dirs_exist_ok=True)
            shutil.rmtree("./bin/Windows/lib")
            print("[YOYO BUILD] Copied dlls to build folder.")

        #  build cleanup, remove the include folder in the output
        if(os.path.exists("./bin/Linux/include")):
            shutil.rmtree("./bin/Linux/include")
        if(os.path.exists("./bin/Windows/include")):
            shutil.rmtree("./bin/Windows/include")

    def run(self):
        # if we recieved arg --run, run the game
        if self.run_flag:
            print("\n----------------------------------")
            print("Running game...")
            print("----------------------------------")
            if(self.game_platform == "linux"):
                subprocess.Popen(["./bin/Linux/" + self.game_name])
            elif(self.game_platform == "windows"):
                # if this script is being run on linux, open this with wine
                if sys.platform == "linux":
                    subprocess.Popen(["wine", "./bin/Windows/"+self.game_name+".exe"])
                else:
                    print("[YOYO BUILD] Error: I have not supported building games not on linux... so you should not be seeing this message at all.")

    
if __name__ == "__main__":
    builder = YoyoEngineBuildSystem()

    print("----------------------------------")
    print("Yoyo Engine Build Script " + builder.script_version)
    print("Ryan Zmuda 2023")
    print("----------------------------------")
    print("Game Name: " + builder.game_name)
    print("Game Platform: " + builder.game_platform)
    print("Build C Flags: " + builder.build_cflags)
    print("----------------------------------")
        
    builder.configure()
    builder.build()
    builder.run()

    print("----------------------------------")
    print("\033[92m" + "Build Successful!" + "\033[0m")
    print("----------------------------------")

#####################
# TODO: PORT TRICKS #
#####################
    
# #
# # WE ARE GOING TO BUILD ALL TRICKS INTO build/platform/tricks
# # optional: later on we can also construct a tricks.yoyo file to compact info on each one

# # create the tricks folder
# os.mkdir("./build/" + build_platform + "/tricks")

# # create a tricks.yoyo file in that folder
# tricks_file = open("./build/" + build_platform + "/tricks/tricks.yoyo", "w")

# # write {"tricks":[]} to set it up
# tricks_file.write("{\"tricks\":[")

# # loop through each folder in ./tricks
# for trick in os.listdir("./tricks"):
#     # if this is not a directory, skip it
#     if not os.path.isdir("./tricks/" + trick):
#         continue

#     # look at its trick.yoyo file and get the name of the trick
#     trick_file = open("./tricks/" + trick + "/trick.yoyo", "r")
#     trick_data = json.load(trick_file)
#     trick_file.close()

#     trick_name = trick_data["name"]
#     trick_description = trick_data["description"]
#     trick_author = trick_data["author"]
#     trick_version = trick_data["version"]

#     print("----------------------------------")
#     print("Building trick \"" + trick_name + "\"...")
#     print("Author: " + trick_author)
#     print("Version: " + trick_version)
#     print(trick_description)
#     print("----------------------------------")

#     # delete the trick's build folder if it exists
#     if os.path.exists("./tricks/" + trick + "/build"):
#         shutil.rmtree("./tricks/" + trick + "/build")

#     # create a build folder in the trick folder
#     os.mkdir("./tricks/" + trick + "/build")

#     # copy the trick's include/ and lib/ folders into the build folder
#     shutil.copytree("./tricks/" + trick + "/include", "./tricks/" + trick + "/build/include", dirs_exist_ok=True)
#     shutil.copytree("./tricks/" + trick + "/lib", "./tricks/" + trick + "/build/lib", dirs_exist_ok=True)

#     # create a CMakeLists.txt file in that folder
#     cmake_file = open("./tricks/" + trick + "/build/CMakeLists.txt", "w")

#     # write to that file the CMakeLists.txt template
#     cmake_file.write("cmake_minimum_required(VERSION 3.22.1)\n")

#     cmake_file.write("project(" + trick_name + ")\n")

#     cmake_file.write("set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} "+build_cflags+"\")\n")

#     cmake_file.write("file(GLOB SOURCES \""+current_dir+"/tricks/"+trick+"/src/*.c\")\n")

#     cmake_file.write("include_directories("+current_dir+"/tricks/"+trick+"/build/include)\n")
#     build_dir = current_dir + "/build/" + build_platform
#     cmake_file.write("include_directories("+build_dir+"/include)\n")

#     cmake_file.write("set(EXECUTIBLE_NAME " + trick_name + ")\n")

#     cmake_file.write("add_library(${EXECUTIBLE_NAME} SHARED ${SOURCES})\n")

#     # run cmake
#     extension = ""
#     if(build_platform == "linux"):
#         extension = ".so"
#     elif(build_platform == "windows"):
#         extension = ".dll"

#     cmake_file.write("file(GLOB LIB_FILES "+current_dir+"/tricks/"+trick+"/build/lib/"+build_platform+"/*"+extension+")\n")

#     cmake_file.write("target_link_directories(${EXECUTIBLE_NAME} PRIVATE "+current_dir+"/tricks/"+trick+"/build/lib)\n")

#     cmake_file.write("target_link_libraries(${EXECUTIBLE_NAME} PRIVATE ${LIB_FILES})\n")

#     cmake_file.close()

#     # print the current working directory of python for debug purposes
#     print("Current working directory: " + os.getcwd())

#     # run cmake
#     if(build_platform == "linux"):
#         subprocess.run(["cmake", "-S", "./tricks/" + trick + "/build", "-B", "./tricks/" + trick + "/build/" + build_platform])
#     elif(build_platform == "windows"):
#         subprocess.run(["cmake", "-DCMAKE_TOOLCHAIN_FILE="+current_dir+"/build/toolchain-win.cmake", "-S", "./tricks/" + trick + "/build", "-B", "./tricks/" + trick + "/build/" + build_platform])

#     # run make
#     subprocess.run(["make", "-C", "./tricks/" + trick + "/build/" + build_platform])

#     # copy the trick's .so or .dll file into ./build/tricks
#     shutil.copyfile("./tricks/" + trick + "/build/" + build_platform + "/lib" + trick_name + extension, "./build/" + build_platform + "/tricks/lib" + trick_name + extension)

#     # copy the trick's include/ to ./build/<platform>/include
#     shutil.copytree("./tricks/" + trick + "/build/include", "./build/" + build_platform + "/include", dirs_exist_ok=True)

#     # copy the trick's lib/ to ./build/<platform>/lib
#     try:
#         if os.path.exists("./tricks/" + trick + "/build/lib/"+build_platform) and os.listdir("./tricks/" + trick + "/build/lib/"+build_platform):
#             shutil.copytree("./tricks/" + trick + "/build/lib/"+build_platform, "./build/" + build_platform + "/lib", dirs_exist_ok=True)
#         else:
#             print("No supplemental libraries found in ./tricks/" + trick + "/build/lib/"+build_platform)
#     except Exception as e:
#         print(f"An error occurred: {e}")

#     # figure out the tricks file name with extension and lib prefix included
#     trick_filename = "lib" + trick_name + extension

#     # populate the tricks.yoyo file with the trick's info, the structure is "tricks":[{trick1}, {trick2}, ...]
#     tricks_file.write("{\"name\":\"" + trick_name + "\",\"description\":\"" + trick_description + "\",\"author\":\"" + trick_author + "\",\"version\":\"" + trick_version + "\",\"filename\":\"" + trick_filename + "\"},")

# # remove the last comma from the tricks.yoyo file
# tricks_file.seek(tricks_file.tell() - 1, os.SEEK_SET)
# tricks_file.truncate()

# # close the tricks.yoyo file
# tricks_file.write("]}")
# tricks_file.close()